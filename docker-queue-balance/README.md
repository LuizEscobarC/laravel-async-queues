# Laravel Async Queues - Docker Queue Balance

> **Sistema de filas distribu√≠das com balanceamento autom√°tico usando Docker + Redis**

## üìã √çndice

- [Vis√£o Geral](#-vis√£o-geral)
- [Conceitos Fundamentais](#-conceitos-fundamentais)
- [Arquitetura do Sistema](#-arquitetura-do-sistema)
- [Load Balancing Autom√°tico](#-load-balancing-autom√°tico)
- [Workers e Prioriza√ß√£o](#-workers-e-prioriza√ß√£o)
- [Diferen√ßas: Docker vs Kubernetes](#-diferen√ßas-docker-vs-kubernetes)
- [Como Funciona na Pr√°tica](#-como-funciona-na-pr√°tica)
- [Comandos e Monitoramento](#-comandos-e-monitoramento)
- [Teoria: Message Brokers](#-teoria-message-brokers)

---

## üéØ Vis√£o Geral

Este projeto demonstra como implementar **filas distribu√≠das** usando Laravel + Docker + Redis, replicando o comportamento do **Laravel Horizon** sem sua complexidade. O sistema implementa **load balancing autom√°tico** entre m√∫ltiplos workers, garantindo alta disponibilidade e processamento eficiente.

### Objetivos Pedag√≥gicos:
- ‚úÖ Entender **load balancing** em sistemas distribu√≠dos
- ‚úÖ Implementar **workers concorrentes** com Docker
- ‚úÖ Compreender **prioriza√ß√£o de filas**
- ‚úÖ Monitorar processamento com **Laravel Telescope**
- ‚úÖ Simular ambiente **production-ready**

---

## üß† Conceitos Fundamentais

### 1. **Message Broker Pattern**
O Redis atua como **intermedi√°rio** entre produtores (app) e consumidores (workers):

```
APP (Producer) ‚Üí REDIS (Message Broker) ‚Üí WORKERS (Consumers)
```

### 2. **FIFO (First In, First Out)**
Jobs s√£o processados na ordem de chegada em cada fila:
- Job mais antigo = primeira prioridade
- Garantia de ordem dentro da mesma fila
- M√∫ltiplos workers competem pelos jobs

### 3. **Competing Consumers Pattern**
M√∫ltiplos workers "competem" pelos mesmos jobs:
- **Atomicidade**: Apenas 1 worker pega cada job
- **Distribui√ß√£o**: Redis distribui automaticamente
- **Efici√™ncia**: Paraleliza√ß√£o sem conflitos

### 4. **Priority Queues**
Sistema de prioridades baseado em import√¢ncia:
- `high-priority`: Jobs cr√≠ticos/urgentes
- `default`: Jobs normais do sistema
- `low-priority`: Jobs em background/cleanup

---

## üèóÔ∏è Arquitetura do Sistema

### Componentes:

```mermaid
graph TB
    A[Laravel App] -->|dispatch jobs| B[Redis Message Broker]
    B -->|FIFO| C[high-priority queue]
    B -->|FIFO| D[default queue] 
    B -->|FIFO| E[low-priority queue]
    
    C --> F[queue-high workers x2]
    D --> G[queue-default workers x2]
    E --> H[queue-low worker x1]
    
    F --> I[Database/Storage]
    G --> I
    H --> I
    
    J[Telescope] -->|monitoring| B
    J -->|tracking| F
    J -->|tracking| G
    J -->|tracking| H
```

### Workers Hierarchy:

| Worker Type | Replicas | Queues Monitored | Sleep | Responsabilidade |
|-------------|----------|------------------|-------|------------------|
| `queue-high` | 2 | high ‚Üí default ‚Üí low | 1s | Jobs cr√≠ticos + overflow |
| `queue-default` | 2 | default ‚Üí low | 2s | Jobs normais + cleanup |
| `queue-low` | 1 | low | 3s | Background tasks |

---

## ‚öñÔ∏è Load Balancing Autom√°tico

### Como Funciona:

#### 1. **Redis como Distribuidor**
```redis
# Jobs ficam em listas Redis
LPUSH queues:high-priority "job1"
LPUSH queues:high-priority "job2" 
LPUSH queues:high-priority "job3"

# Workers fazem BRPOP (blocking pop)
BRPOP queues:high-priority 5  # Worker 1 pega job1
BRPOP queues:high-priority 5  # Worker 2 pega job2
```

#### 2. **Competi√ß√£o Autom√°tica**
- **Atomicidade**: Redis garante que apenas 1 worker pega cada job
- **Distribui√ß√£o**: Naturalmente balanceada entre workers dispon√≠veis
- **Performance**: Sem overhead de coordena√ß√£o central

#### 3. **Exemplo Pr√°tico**
Despachando 100 jobs para `high-priority`:

```
Worker queue-high-1: Jobs 1, 3, 5, 7, 9...  (50 jobs)
Worker queue-high-2: Jobs 2, 4, 6, 8, 10... (50 jobs)
```

**Resultado**: Distribui√ß√£o autom√°tica ~50/50 sem configura√ß√£o!

### Vantagens:

‚úÖ **Zero configura√ß√£o** - Redis faz tudo automaticamente  
‚úÖ **Fault tolerance** - Worker falha? Outros continuam  
‚úÖ **Linear scaling** - Mais workers = Mais throughput  
‚úÖ **No single point** - Sem coordenador central  
‚úÖ **Resource efficient** - Workers ociosos dormem  

---

## üë• Workers e Prioriza√ß√£o

### Sistema de Prioriza√ß√£o Inteligente:

#### **Queue-High Workers (2 replicas)**
```yaml
command: php artisan queue:work redis --queue=high-priority,default,low-priority --sleep=1
```

**Comportamento:**
1. üî• Procura jobs em `high-priority` (urgente)
2. ‚ö° Se vazia, procura em `default` (normal)
3. üêå Se vazia, procura em `low-priority` (background)
4. üò¥ Se tudo vazio, dorme 1 segundo

#### **Queue-Default Workers (2 replicas)**
```yaml
command: php artisan queue:work redis --queue=default,low-priority --sleep=2
```

**Comportamento:**
1. ‚ö° Procura jobs em `default`
2. üêå Se vazia, procura em `low-priority`
3. üò¥ Se tudo vazio, dorme 2 segundos

#### **Queue-Low Worker (1 replica)**
```yaml
command: php artisan queue:work redis --queue=low-priority --sleep=3
```

**Comportamento:**
1. üêå S√≥ processa `low-priority`
2. üò¥ Se vazia, dorme 3 segundos

### Cen√°rios de Carga:

| Situa√ß√£o | High Workers | Default Workers | Low Worker |
|----------|--------------|-----------------|------------|
| **Pico de tr√°fego** | Processam high + overflow para default/low | Ajudam com default + low | Limpa low-priority |
| **Carga normal** | Processam high + ajudam default | Processam default + low | Processa low |
| **Baixa carga** | Ociosos (dormindo) | Processam default | Processa low |

---

## üîÑ Diferen√ßas: Docker vs Kubernetes

### **Docker Compose (Este Projeto)**

#### Caracter√≠sticas:
- üîí **Replicas Est√°ticas** - N√∫mero fixo definido no YAML
- üìä **Previs√≠vel** - Sempre o mesmo n√∫mero de containers
- üõ†Ô∏è **Scaling Manual** - Via comando ou edi√ß√£o do arquivo
- üí∞ **Recursos Constantes** - Sempre consumindo a mesma quantidade

#### Configura√ß√£o:
```yaml
deploy:
  replicas: 2  # SEMPRE 2 containers rodando
```

#### Scaling:
```bash
# Manual - editando arquivo
vim docker-compose.yml  # replicas: 5

# Manual - via comando
docker-compose up --scale queue-high=5 -d
```

### **Kubernetes (Compara√ß√£o)**

#### Caracter√≠sticas:
- üîÑ **Auto-scaling** - Baseado em m√©tricas (CPU, mem√≥ria, custom)
- üìà **Din√¢mico** - Aumenta/diminui conforme demanda
- ü§ñ **Autom√°tico** - HPA/VPA fazem o trabalho
- üí° **Resource-aware** - Considera recursos dispon√≠veis

#### Configura√ß√£o:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
spec:
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  # Escala de 1-10 baseado em CPU
```

#### Scaling:
```yaml
# Autom√°tico baseado em m√©tricas
metrics:
- type: Resource
  resource:
    name: cpu
    target:
      type: Utilization
      averageUtilization: 70
```

### **Quando Usar Cada Um:**

| Aspecto | Docker Compose | Kubernetes |
|---------|----------------|------------|
| **Aprendizado** | ‚úÖ Ideal | ‚ùå Complexo |
| **Desenvolvimento** | ‚úÖ Simples | ‚ùå Overhead |
| **Produ√ß√£o pequena** | ‚úÖ Suficiente | ‚ùå Over-engineering |
| **Produ√ß√£o enterprise** | ‚ùå Limitado | ‚úÖ Ideal |
| **Auto-scaling** | ‚ùå Manual | ‚úÖ Autom√°tico |
| **Monitoring** | ‚ö†Ô∏è B√°sico | ‚úÖ Avan√ßado |

---

## ‚öôÔ∏è Como Funciona na Pr√°tica

### 1. **Despacho de Jobs**

```php
// Job automaticamente escolhe a fila baseada no batch size
ProcessCsvDataJob::dispatch($data, $batchSize);

// Ou definir fila explicitamente
ProcessCsvDataJob::dispatch($data)->onQueue('high-priority');
```

### 2. **Processamento Distribu√≠do**

```
1. App despacha 100 jobs para high-priority
2. Redis armazena jobs na lista queues:high-priority
3. Workers queue-high fazem BRPOP para pegar jobs
4. Redis distribui automaticamente entre os 2 workers
5. Cada worker processa ~50 jobs
6. Telescope registra todo o processo
```

### 3. **Toler√¢ncia a Falhas**

```
Se queue-high-1 falhar:
- queue-high-2 continua processando
- Jobs n√£o processados ficam na fila
- Docker restart: unless-stopped recria o container
- Processamento continua sem perda de jobs
```

### 4. **Prioriza√ß√£o Din√¢mica**

```
Cen√°rio: 50 jobs high + 100 jobs default + 200 jobs low

Resultado:
- queue-high workers: Focam em high, depois ajudam default
- queue-default workers: Processam default, depois low  
- queue-low worker: Limpa low-priority restante
```

---

## üìä Comandos e Monitoramento

### **Inicializa√ß√£o**
```bash
# Subir todo o ambiente
docker-compose up -d

# Verificar status dos workers
docker-compose ps

# Ver logs em tempo real
docker-compose logs -f queue-high
```

### **Processamento de Dados**
```bash
# Processar CSV com batch pequeno (low-priority)
docker-compose exec app php artisan process:csv-data --batch-size=10

# Processar com batch m√©dio (default)
docker-compose exec app php artisan process:csv-data --batch-size=30

# Processar com batch grande (high-priority)  
docker-compose exec app php artisan process:csv-data --batch-size=60
```

### **Monitoramento Redis**
```bash
# Conectar no Redis
docker-compose exec redis redis-cli

# Ver jobs pendentes
LLEN queues:high-priority
LLEN queues:default
LLEN queues:low-priority

# Ver jobs em processamento
KEYS queues:*:reserved

# Monitorar em tempo real
MONITOR
```

### **Telescope Dashboard**
- **URL**: http://localhost:8080/telescope
- **Se√ß√£o Jobs**: Visualizar todos os jobs das 3 filas
- **Filtros**: Por status (pending, processing, completed, failed)
- **Detalhes**: Tempo de execu√ß√£o, payload, queue utilizada

### **Scaling Manual**
```bash
# Aumentar workers de alta prioridade
docker-compose up --scale queue-high=4 -d

# Diminuir workers de baixa prioridade
docker-compose up --scale queue-low=0 -d

# Verificar nova configura√ß√£o
docker ps | grep queue
```

---

## üî¨ Teoria: Message Brokers

### **O que √© um Message Broker?**

Um **Message Broker** √© um intermedi√°rio que facilita a comunica√ß√£o entre diferentes partes de um sistema distribu√≠do. No nosso caso, o **Redis** atua como broker entre a aplica√ß√£o Laravel (producer) e os workers (consumers).

### **Padr√µes Implementados:**

#### 1. **Producer-Consumer Pattern**
```
Producer (Laravel App) ‚Üí Broker (Redis) ‚Üí Consumer (Workers)
```

**Benef√≠cios:**
- **Desacoplamento**: App n√£o precisa conhecer workers
- **Escalabilidade**: Adicionar workers n√£o afeta o app
- **Reliability**: Jobs persistem mesmo se workers estiverem down

#### 2. **Competing Consumers Pattern**
```
Producer ‚Üí Queue ‚Üí [Consumer1, Consumer2, Consumer3...]
```

**Caracter√≠sticas:**
- M√∫ltiplos consumers processam da mesma fila
- Cada mensagem √© processada por apenas UM consumer
- Load balancing autom√°tico entre consumers

#### 3. **Priority Queue Pattern**
```
Producer ‚Üí [High Queue, Default Queue, Low Queue] ‚Üí Consumers
```

**Implementa√ß√£o:**
- Workers verificam filas por ordem de prioridade
- Jobs cr√≠ticos s√£o processados primeiro
- Background tasks n√£o bloqueiam jobs importantes

### **Vantagens do Redis como Broker:**

‚úÖ **Performance**: Opera√ß√µes in-memory extremamente r√°pidas  
‚úÖ **Atomicidade**: BRPOP garante que apenas 1 worker pega cada job  
‚úÖ **Persistence**: AOF/RDB garantem durabilidade dos jobs  
‚úÖ **Simplicidade**: Estrutura de dados simples (listas)  
‚úÖ **Monitoring**: Comandos nativos para observabilidade  

### **Compara√ß√£o com Outros Brokers:**

| Feature | Redis | RabbitMQ | Apache Kafka |
|---------|-------|----------|--------------|
| **Performance** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Simplicidade** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Durabilidade** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Scaling** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Laravel Integration** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |

---

## üéì Conclus√£o

Este projeto demonstra conceitos fundamentais de **sistemas distribu√≠dos** aplicados ao processamento de filas:

### **Conceitos Aprendidos:**
- ‚úÖ **Load Balancing** autom√°tico com Redis
- ‚úÖ **Competing Consumers** para alta performance
- ‚úÖ **Priority Queues** para gest√£o de recursos
- ‚úÖ **Fault Tolerance** com m√∫ltiplos workers
- ‚úÖ **Monitoring** em tempo real com Telescope
- ‚úÖ **Container Orchestration** com Docker Compose

### **Aplica√ß√µes no Mundo Real:**
- üè¢ **E-commerce**: Processamento de pedidos por prioridade
- üìß **Email Marketing**: Envio distribu√≠do de campanhas  
- üñºÔ∏è **Media Processing**: Redimensionamento de imagens
- üìä **Data Pipeline**: ETL de grandes volumes de dados
- üîî **Notifications**: Push notifications escal√°veis

### **Pr√≥ximos Passos:**
1. üöÄ **Kubernetes**: Migrar para auto-scaling real
2. üìà **Monitoring**: Prometheus + Grafana
3. üîÑ **Circuit Breaker**: Resil√™ncia avan√ßada
4. üåê **Multi-Region**: Distribui√ß√£o geogr√°fica
5. üîê **Security**: Autentica√ß√£o e autoriza√ß√£o

---

## üìö Recursos Adicionais

- [Laravel Queues Documentation](https://laravel.com/docs/queues)
- [Redis Commands Reference](https://redis.io/commands)
- [Docker Compose Reference](https://docs.docker.com/compose/)
- [Laravel Telescope](https://laravel.com/docs/telescope)
- [Message Patterns](https://www.enterpriseintegrationpatterns.com/patterns/messaging/)

---

**üîó Autor**: Luiz Escobal  
**üìÖ Data**: Junho 2025  
**üéØ Objetivo**: Aprendizado de Sistemas Distribu√≠dos com Laravel

